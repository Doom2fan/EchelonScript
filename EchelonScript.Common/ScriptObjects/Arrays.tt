<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
/*
 * EchelonScript
 * Copyright (C) 2020- Chronos "phantombeta" Ouroboros
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

//=============================================================================
//
// This file was automatically generated by a text template. If you want to make modifications, do so in the .tt file.
//
//=============================================================================

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using CommunityToolkit.HighPerformance;
using EchelonScript.Common.Data;
using EchelonScript.Common.Data.Types;
using EchelonScript.Common.Exporting;

namespace EchelonScript.Common;
<#
    var indexLetters = new [] { "x", "y", "z", "w" };
    var modesList = new [] { Mode.Mutable, Mode.Immutable, Mode.Const, };
    var maxArrayRank = 4;
#>

static partial class ES_Utils {
    public static bool TryGetNativeArrayInfo (Type type, [NotNullWhen (true)] out Type? elemType, out int rank, out ES_Constness constness) {
        if (!type.IsConstructedGenericType) {
            elemType = null;
            rank = 0;
            constness = default;

            return false;
        }

        var genType = type.GetGenericTypeDefinition ();

<#
    foreach (var mode in modesList) {
        for (int i = 1; i <= maxArrayRank; i++) {
#>
        if (genType == typeof (<#= GetName (i, mode) #><>)) {
            rank = <#= i #>;
            constness = <#= GetConstness (mode) #>;

            goto Success;
        }
<#
        }
    }
#>

        elemType = null;
        rank = 0;
        constness = default;

        return false;

    Success:
        var genArgs = type.GetGenericArguments ();
        Debug.Assert (genArgs is not null && genArgs.Length == 1);

        elemType = genArgs [0];
        return true;
    }
}
<#
    var nameConst1D = GetName (1, Mode.Const);
    for (int curRank = 1; curRank <= maxArrayRank; curRank++) {
        var constName = GetName (curRank, Mode.Const);
        foreach (var mode in modesList) {
            var isMutable = mode == Mode.Mutable;
            var typeName = GetName (curRank, mode);
            var idxrModifier = isMutable ? " ref" : "";
            var interfaces = $"IES_ReferenceType, IEquatable<{typeName}<T>>";

            if (mode != Mode.Const)
                interfaces += $", IEquatable<{constName}<T>>";
            else foreach (var otherMode in modesList) {
                if (otherMode != mode)
                    interfaces += $", IEquatable<{GetName (curRank, otherMode)}<T>>";
            }
#>

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct <#= typeName #><T> : <#= interfaces #>
    where T : unmanaged {
    public static <#= typeName #><T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;
<# if (curRank == 1 || curRank == 2) { #>

    public <#= !isMutable ? "ReadOnly" : "" #><#= curRank == 1 ? "Span" : "Span2D" #><T> Span {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
<# if (curRank == 1) { #>
            if (arrayPtr == null)
                return Span<T>.Empty;

            return new (ES_ArrayHeader.GetArrayDataPointer (arrayPtr), arrayPtr->Length);
<# } else { #>
            if (arrayPtr == null)
                return Span2D<T>.Empty;

            Debug.Assert (arrayPtr->Rank == 2);

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer (arrayPtr);
            var ranks = GetRanks ();

            return new (dataPtr, ranks [0], ranks [1], 0);
<# } #>
        }
    }
<# } #>

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal <#= typeName #> (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal <#= typeName #> (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public<#= idxrModifier #> T this [<#
        if (curRank > 1) {
            for (int otherRank = 0; otherRank < curRank; otherRank++) {
                if (otherRank > 0)
                    Write (", ");

                Write ($"ES_ArrayIndex {indexLetters [otherRank]}");
            }
        } else
            Write ("ES_ArrayIndex idx");
    #>] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
<#  if (curRank == 1) { #>
            if (idx < 0 || idx >= arrayPtr->Length)
                throw new IndexOutOfRangeException ("Index is out of range.");

            return<#= idxrModifier #> dataPtr [idx];
<# } else { #>
            var ranks = GetRanks ();

<#
    for (int otherRank = 0; otherRank < curRank; otherRank++) {
        var idxLetter = indexLetters [otherRank];
#>
            <#= $"if ({idxLetter} < 0 || {idxLetter} >= ranks [{otherRank}])" #>
                throw new IndexOutOfRangeException ("Index <#= idxLetter #> is out of range.");
<# } #>

            return<#= idxrModifier #> dataPtr [<#
                for (int otherRank = 0; otherRank < curRank; otherRank++) {
                    if (otherRank > 0)
                        Write (" + ");

                    Write (indexLetters [otherRank]);

                    for (int k = 0; k < otherRank; k++)
                        Write ($" * ranks [{k}]");
                }
            #>];
<# } #>
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

<#
    if (mode != Mode.Const) {
#>
    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static implicit operator <#= constName #><T> (<#= typeName #><T> self) => new (self.arrayPtr);
<#
        if (curRank > 1) {
#>

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator <#= typeName #><T> (<#= GetName (1, mode) #><T> other) {
        if (other.arrayPtr->Rank != <#= curRank #>)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public <#= GetName (1, mode) #><T> AsArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public <#= nameConst1D #><T> AsConstArray1D () => new (arrayPtr);
<#
        }
#>

    <#= GetEqualsOp (false, typeName, typeName) #>

    <#= GetEqualsOp (true, typeName, typeName) #>

    <#= GetEqualsOp (false, typeName, constName) #>

    <#= GetEqualsOp (true, typeName, constName) #>

    <#= GetEqualsFunc (typeName) #>

    <#= GetEqualsFunc (constName) #>

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is <#= typeName #><T> other)
            return Equals (other);
        else if (obj is <#= constName #><T> otherConst)
            return Equals (otherConst);

        return false;
    }
<#
    } else {
#>
    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public <#= nameConst1D #><T> AsConstArray1D () => new (arrayPtr);
<#
        foreach (var otherMode in modesList) {
            var otherModeName = GetName (curRank, otherMode);
            if (curRank > 1) {
#>

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator <#= typeName #><T> (<#= GetName (1, otherMode) #><T> other) {
        if (other.arrayPtr->Rank != <#= curRank #>)
            return new (null);

        return new (other.arrayPtr);
    }
<#
            }
#>

    <#= GetEqualsOp (false, typeName, otherModeName) #>

    <#= GetEqualsOp (true, typeName, otherModeName) #>

    <#= GetEqualsFunc (otherModeName) #>
<#
        }
#>

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
<#
            foreach (var otherMode in modesList) {

                var otherName = GetName (curRank, otherMode);
                var varName = $"other{otherMode}";
#>
        if (obj is <#= otherName #><T> <#= varName #>)
            return Equals (<#= varName #>);
<#
            }
#>

        return false;
    }
<#
    }
#>

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_NativeTypeTable.NativeTypeLoader typeLoader, ref ES_NativeTypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, <#= GetConstness (mode) #>, <#= curRank #>);
    }

    #endregion
}
<#
        }
    }
#>

<#+
    enum Mode {
        Mutable,
        Const,
        Immutable,
    }

    string GetName (int rank, Mode mode) => mode switch {
        Mode.Mutable => $"ES_Array{rank}D",
        Mode.Const => $"ES_ConstArray{rank}D",
        Mode.Immutable => $"ES_ImmutArray{rank}D",

        _ => throw new Exception ("Huh?"),
    };

    string GetConstness (Mode mode) => mode switch {
        Mode.Mutable => "ES_Constness.Mutable",
        Mode.Const => "ES_Constness.Const",
        Mode.Immutable => "ES_Constness.Immutable",

        _ => throw new Exception ("Huh?"),
    };

    string GetEqualsFunc (string otherName) {
        return $"[MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals ({otherName}<T> other) => other.arrayPtr == arrayPtr;";
    }

    string GetEqualsOp (bool notEq, string leftName, string rightName) {
        return $"[MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator {(notEq ? "!=" : "==")} ({leftName}<T> left, {rightName}<T> right) => {(notEq ? "!" : "")}left.Equals (right);";
    }
#>