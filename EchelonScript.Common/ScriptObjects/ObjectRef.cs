/*
 * EchelonScript
 * Copyright (C) 2020- Chronos "phantombeta" Ouroboros
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

//=============================================================================
//
// This file was automatically generated by a text template. If you want to make modifications, do so in the .tt file.
//
//=============================================================================

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using EchelonScript.Common.Data.Types;

namespace EchelonScript.Common;

static partial class ES_Utils {
    public static bool TryGetNativeObjectRefInfo (Type type, [NotNullWhen (true)] out Type? pointedType, out ES_Constness constness) {
        if (!type.IsConstructedGenericType) {
            pointedType = null;
            constness = default;

            return false;
        }

        var genType = type.GetGenericTypeDefinition ();

        if (genType == typeof (ES_Object<>)) {
            constness = ES_Constness.Mutable;

            goto Success;
        }
        if (genType == typeof (ES_ObjectImmut<>)) {
            constness = ES_Constness.Immutable;

            goto Success;
        }
        if (genType == typeof (ES_ObjectConst<>)) {
            constness = ES_Constness.Const;

            goto Success;
        }

        pointedType = null;
        constness = default;

        return false;

    Success:
        var genArgs = type.GetGenericArguments ();
        Debug.Assert (genArgs is not null && genArgs.Length == 1);

        pointedType = genArgs [0];
        return true;
    }
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_Object<T> : IEquatable<ES_Object<T>>, IEquatable<ES_ObjectConst<T>>
    where T : unmanaged {
    public static ES_Object<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (ES_ObjectAddress.Null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ObjectAddress objPtr;

    public ref T Value {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            return ref *(T*) objPtr.Address;
        }
    }

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_Object (ES_ObjectAddress ptr) => objPtr = ptr;

    #region ================== Methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => objPtr.Address == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static implicit operator ES_ObjectConst<T> (ES_Object<T> self) => new (self.objPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_Object<T> left, ES_Object<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_Object<T> left, ES_Object<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_Object<T> left, ES_ObjectConst<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_Object<T> left, ES_ObjectConst<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_Object<T> other) => other.objPtr.Address == objPtr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ObjectConst<T> other) => other.objPtr.Address == objPtr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_Object<T> other)
            return Equals (other);
        else if (obj is ES_ObjectConst<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) objPtr.Address).GetHashCode ();

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_ObjectImmut<T> : IEquatable<ES_ObjectImmut<T>>, IEquatable<ES_ObjectConst<T>>
    where T : unmanaged {
    public static ES_ObjectImmut<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (ES_ObjectAddress.Null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ObjectAddress objPtr;

    public ref readonly T Value {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            return ref *(T*) objPtr.Address;
        }
    }

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ObjectImmut (ES_ObjectAddress ptr) => objPtr = ptr;

    #region ================== Methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => objPtr.Address == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static implicit operator ES_ObjectConst<T> (ES_ObjectImmut<T> self) => new (self.objPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ObjectImmut<T> left, ES_ObjectImmut<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ObjectImmut<T> left, ES_ObjectImmut<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ObjectImmut<T> left, ES_ObjectConst<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ObjectImmut<T> left, ES_ObjectConst<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ObjectImmut<T> other) => other.objPtr.Address == objPtr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ObjectConst<T> other) => other.objPtr.Address == objPtr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_ObjectImmut<T> other)
            return Equals (other);
        else if (obj is ES_ObjectConst<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) objPtr.Address).GetHashCode ();

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_ObjectConst<T> : IEquatable<ES_ObjectConst<T>>, IEquatable<ES_Object<T>>, IEquatable<ES_ObjectImmut<T>>
    where T : unmanaged {
    public static ES_ObjectConst<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (ES_ObjectAddress.Null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ObjectAddress objPtr;

    public ref readonly T Value {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            return ref *(T*) objPtr.Address;
        }
    }

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ObjectConst (ES_ObjectAddress ptr) => objPtr = ptr;

    #region ================== Methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => objPtr.Address == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ObjectConst<T> left, ES_Object<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ObjectConst<T> left, ES_Object<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_Object<T> other) => other.objPtr.Address == objPtr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ObjectConst<T> left, ES_ObjectImmut<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ObjectConst<T> left, ES_ObjectImmut<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ObjectImmut<T> other) => other.objPtr.Address == objPtr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ObjectConst<T> left, ES_ObjectConst<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ObjectConst<T> left, ES_ObjectConst<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ObjectConst<T> other) => other.objPtr.Address == objPtr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_Object<T> otherMutable)
            return Equals (otherMutable);
        if (obj is ES_ObjectImmut<T> otherImmutable)
            return Equals (otherImmutable);
        if (obj is ES_ObjectConst<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) objPtr.Address).GetHashCode ();

    #endregion
}

