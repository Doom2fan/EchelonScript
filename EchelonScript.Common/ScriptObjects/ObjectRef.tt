<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
/*
 * EchelonScript
 * Copyright (C) 2020- Chronos "phantombeta" Ouroboros
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

//=============================================================================
//
// This file was automatically generated by a text template. If you want to make modifications, do so in the .tt file.
//
//=============================================================================

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using EchelonScript.Common.Data;
using EchelonScript.Common.Exporting;

namespace EchelonScript.Common;
<#
    var modesList = new [] { Mode.Mutable, Mode.Immutable, Mode.Const, };
#>

static partial class ES_Utils {
    public static bool TryGetNativeObjectRefInfo (Type type, [NotNullWhen (true)] out Type? pointedType, out ES_Constness constness) {
        if (!type.IsConstructedGenericType) {
            pointedType = null;
            constness = default;

            return false;
        }

        var genType = type.GetGenericTypeDefinition ();

<#
    foreach (var mode in modesList) {
#>
        if (genType == typeof (<#= GetName (mode) #><>)) {
            constness = <#= GetConstness (mode) #>;

            goto Success;
        }
<#
    }
#>

        pointedType = null;
        constness = default;

        return false;

    Success:
        var genArgs = type.GetGenericArguments ();
        Debug.Assert (genArgs is not null && genArgs.Length == 1);

        pointedType = genArgs [0];
        return true;
    }
}
<#
    var constName = GetName (Mode.Const);
    foreach (var mode in modesList) {
        var isMutable = mode == Mode.Mutable;
        var typeName = $"{GetName (mode)}";
        var interfaces = $"IES_ReferenceType, IEquatable<{typeName}<T>>";
        var valModifier = isMutable ? " ref" : " ref readonly";

        if (mode != Mode.Const)
            interfaces += $", IEquatable<{constName}<T>>";
        else foreach (var otherMode in modesList) {
            if (otherMode != mode)
                interfaces += $", IEquatable<{GetName (otherMode)}<T>>";
        }
#>

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct <#= typeName #><T> : <#= interfaces #>
    where T : unmanaged {
    public static <#= typeName #><T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (ES_ObjectAddress.Null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ObjectAddress objPtr;

    public<#= valModifier #> T Value {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            return ref *(T*) objPtr.Address;
        }
    }

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal <#= GetName (mode) #> (ES_ObjectAddress ptr) => objPtr = ptr;

    #region ================== Methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => objPtr.Address == null;
<#
        if (mode != Mode.Const) {
#>

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static implicit operator <#= constName #><T> (<#= typeName #><T> self) => new (self.objPtr);

    <#= GetEqualsOp (false, typeName, typeName) #>

    <#= GetEqualsOp (true, typeName, typeName) #>

    <#= GetEqualsOp (false, typeName, constName) #>

    <#= GetEqualsOp (true, typeName, constName) #>

    <#= GetEqualsFunc (typeName) #>

    <#= GetEqualsFunc (constName) #>

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is <#= typeName #><T> other)
            return Equals (other);
        else if (obj is <#= constName #><T> otherConst)
            return Equals (otherConst);

        return false;
    }
<#
        } else {
            foreach (var otherMode in modesList) {
                var otherName = $"{GetName (otherMode)}<T>";
#>

    <#= GetEqualsOp (false, typeName, otherName) #>

    <#= GetEqualsOp (true, typeName, otherName) #>

    <#= GetEqualsFunc (otherName) #>
<#
            }
#>

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
<#
            foreach (var otherMode in modesList) {

                var otherName = GetName (otherMode);
                var varName = $"other{otherMode}";
#>
        if (obj is <#= otherName #><T> <#= varName #>)
            return Equals (<#= varName #>);
<#
            }
#>

        return false;
    }
<#
        }
#>

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) objPtr.Address).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateReference<T> (ref typeToken, <#= GetConstness (mode) #>);
    }

    #endregion
}
<#
    }
#>

<#+
    enum Mode {
        Mutable,
        Const,
        Immutable,
    }

    string GetName (Mode mode) {
        return mode switch {
            Mode.Mutable => "ES_Object",
            Mode.Const => "ES_ObjectConst",
            Mode.Immutable => "ES_ObjectImmut",

            _ => throw new Exception ("Huh?"),
        };
    }

    string GetConstness (Mode mode) => mode switch {
        Mode.Mutable => "ES_Constness.Mutable",
        Mode.Const => "ES_Constness.Const",
        Mode.Immutable => "ES_Constness.Immutable",

        _ => throw new Exception ("Huh?"),
    };

    string GetEqualsFunc (string otherName) {
        if (!otherName.EndsWith ("<T>"))
            otherName += "<T>";

        return $"[MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals ({otherName} other) => other.objPtr.Address == objPtr.Address;";
    }

    string GetEqualsOp (bool notEq, string leftName, string rightName) {
        if (!leftName.EndsWith ("<T>"))
            leftName += "<T>";
        if (!rightName.EndsWith ("<T>"))
            rightName += "<T>";

        return $"[MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator {(notEq ? "!=" : "==")} ({leftName} left, {rightName} right) => {(notEq ? "!" : "")}left.Equals (right);";
    }
#>