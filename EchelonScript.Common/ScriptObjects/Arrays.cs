/*
 * EchelonScript
 * Copyright (C) 2020- Chronos "phantombeta" Ouroboros
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

//=============================================================================
//
// This file was automatically generated by a text template. If you want to make modifications, do so in the .tt file.
//
//=============================================================================

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using CommunityToolkit.HighPerformance;
using EchelonScript.Common.Data;
using EchelonScript.Common.Exporting;

namespace EchelonScript.Common;

static partial class ES_Utils {
    public static bool TryGetNativeArrayInfo (Type type, [NotNullWhen (true)] out Type? elemType, out int rank, out ES_Constness constness) {
        if (!type.IsConstructedGenericType) {
            elemType = null;
            rank = 0;
            constness = default;

            return false;
        }

        var genType = type.GetGenericTypeDefinition ();

        if (genType == typeof (ES_Array1D<>)) {
            rank = 1;
            constness = ES_Constness.Mutable;

            goto Success;
        }
        if (genType == typeof (ES_Array2D<>)) {
            rank = 2;
            constness = ES_Constness.Mutable;

            goto Success;
        }
        if (genType == typeof (ES_Array3D<>)) {
            rank = 3;
            constness = ES_Constness.Mutable;

            goto Success;
        }
        if (genType == typeof (ES_Array4D<>)) {
            rank = 4;
            constness = ES_Constness.Mutable;

            goto Success;
        }
        if (genType == typeof (ES_ImmutArray1D<>)) {
            rank = 1;
            constness = ES_Constness.Immutable;

            goto Success;
        }
        if (genType == typeof (ES_ImmutArray2D<>)) {
            rank = 2;
            constness = ES_Constness.Immutable;

            goto Success;
        }
        if (genType == typeof (ES_ImmutArray3D<>)) {
            rank = 3;
            constness = ES_Constness.Immutable;

            goto Success;
        }
        if (genType == typeof (ES_ImmutArray4D<>)) {
            rank = 4;
            constness = ES_Constness.Immutable;

            goto Success;
        }
        if (genType == typeof (ES_ConstArray1D<>)) {
            rank = 1;
            constness = ES_Constness.Const;

            goto Success;
        }
        if (genType == typeof (ES_ConstArray2D<>)) {
            rank = 2;
            constness = ES_Constness.Const;

            goto Success;
        }
        if (genType == typeof (ES_ConstArray3D<>)) {
            rank = 3;
            constness = ES_Constness.Const;

            goto Success;
        }
        if (genType == typeof (ES_ConstArray4D<>)) {
            rank = 4;
            constness = ES_Constness.Const;

            goto Success;
        }

        elemType = null;
        rank = 0;
        constness = default;

        return false;

    Success:
        var genArgs = type.GetGenericArguments ();
        Debug.Assert (genArgs is not null && genArgs.Length == 1);

        elemType = genArgs [0];
        return true;
    }
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_Array1D<T> : IES_ReferenceType, IEquatable<ES_Array1D<T>>, IEquatable<ES_ConstArray1D<T>>
    where T : unmanaged {
    public static ES_Array1D<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;

    public Span<T> Span {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (arrayPtr == null)
                return Span<T>.Empty;

            return new (ES_ArrayHeader.GetArrayDataPointer (arrayPtr), arrayPtr->Length);
        }
    }

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_Array1D (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_Array1D (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public ref T this [ES_ArrayIndex idx] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
            if (idx < 0 || idx >= arrayPtr->Length)
                throw new IndexOutOfRangeException ("Index is out of range.");

            return ref dataPtr [idx];
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static implicit operator ES_ConstArray1D<T> (ES_Array1D<T> self) => new (self.arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_Array1D<T> left, ES_Array1D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_Array1D<T> left, ES_Array1D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_Array1D<T> left, ES_ConstArray1D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_Array1D<T> left, ES_ConstArray1D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_Array1D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ConstArray1D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_Array1D<T> other)
            return Equals (other);
        else if (obj is ES_ConstArray1D<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, ES_Constness.Mutable, 1);
    }

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_ImmutArray1D<T> : IES_ReferenceType, IEquatable<ES_ImmutArray1D<T>>, IEquatable<ES_ConstArray1D<T>>
    where T : unmanaged {
    public static ES_ImmutArray1D<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;

    public ReadOnlySpan<T> Span {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (arrayPtr == null)
                return Span<T>.Empty;

            return new (ES_ArrayHeader.GetArrayDataPointer (arrayPtr), arrayPtr->Length);
        }
    }

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ImmutArray1D (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ImmutArray1D (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public T this [ES_ArrayIndex idx] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
            if (idx < 0 || idx >= arrayPtr->Length)
                throw new IndexOutOfRangeException ("Index is out of range.");

            return dataPtr [idx];
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static implicit operator ES_ConstArray1D<T> (ES_ImmutArray1D<T> self) => new (self.arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ImmutArray1D<T> left, ES_ImmutArray1D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ImmutArray1D<T> left, ES_ImmutArray1D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ImmutArray1D<T> left, ES_ConstArray1D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ImmutArray1D<T> left, ES_ConstArray1D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ImmutArray1D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ConstArray1D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_ImmutArray1D<T> other)
            return Equals (other);
        else if (obj is ES_ConstArray1D<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, ES_Constness.Immutable, 1);
    }

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_ConstArray1D<T> : IES_ReferenceType, IEquatable<ES_ConstArray1D<T>>, IEquatable<ES_Array1D<T>>, IEquatable<ES_ImmutArray1D<T>>
    where T : unmanaged {
    public static ES_ConstArray1D<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;

    public ReadOnlySpan<T> Span {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (arrayPtr == null)
                return Span<T>.Empty;

            return new (ES_ArrayHeader.GetArrayDataPointer (arrayPtr), arrayPtr->Length);
        }
    }

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ConstArray1D (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ConstArray1D (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public T this [ES_ArrayIndex idx] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
            if (idx < 0 || idx >= arrayPtr->Length)
                throw new IndexOutOfRangeException ("Index is out of range.");

            return dataPtr [idx];
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ConstArray1D<T> AsConstArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ConstArray1D<T> left, ES_Array1D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ConstArray1D<T> left, ES_Array1D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_Array1D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ConstArray1D<T> left, ES_ImmutArray1D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ConstArray1D<T> left, ES_ImmutArray1D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ImmutArray1D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ConstArray1D<T> left, ES_ConstArray1D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ConstArray1D<T> left, ES_ConstArray1D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ConstArray1D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_Array1D<T> otherMutable)
            return Equals (otherMutable);
        if (obj is ES_ImmutArray1D<T> otherImmutable)
            return Equals (otherImmutable);
        if (obj is ES_ConstArray1D<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, ES_Constness.Const, 1);
    }

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_Array2D<T> : IES_ReferenceType, IEquatable<ES_Array2D<T>>, IEquatable<ES_ConstArray2D<T>>
    where T : unmanaged {
    public static ES_Array2D<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;

    public Span2D<T> Span {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (arrayPtr == null)
                return Span2D<T>.Empty;

            Debug.Assert (arrayPtr->Rank == 2);

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer (arrayPtr);
            var ranks = GetRanks ();

            return new (dataPtr, ranks [0], ranks [1], 0);
        }
    }

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_Array2D (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_Array2D (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public ref T this [ES_ArrayIndex x, ES_ArrayIndex y] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
            var ranks = GetRanks ();

            if (x < 0 || x >= ranks [0])
                throw new IndexOutOfRangeException ("Index x is out of range.");
            if (y < 0 || y >= ranks [1])
                throw new IndexOutOfRangeException ("Index y is out of range.");

            return ref dataPtr [x + y * ranks [0]];
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static implicit operator ES_ConstArray2D<T> (ES_Array2D<T> self) => new (self.arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_Array2D<T> (ES_Array1D<T> other) {
        if (other.arrayPtr->Rank != 2)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_Array1D<T> AsArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ConstArray1D<T> AsConstArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_Array2D<T> left, ES_Array2D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_Array2D<T> left, ES_Array2D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_Array2D<T> left, ES_ConstArray2D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_Array2D<T> left, ES_ConstArray2D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_Array2D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ConstArray2D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_Array2D<T> other)
            return Equals (other);
        else if (obj is ES_ConstArray2D<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, ES_Constness.Mutable, 2);
    }

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_ImmutArray2D<T> : IES_ReferenceType, IEquatable<ES_ImmutArray2D<T>>, IEquatable<ES_ConstArray2D<T>>
    where T : unmanaged {
    public static ES_ImmutArray2D<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;

    public ReadOnlySpan2D<T> Span {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (arrayPtr == null)
                return Span2D<T>.Empty;

            Debug.Assert (arrayPtr->Rank == 2);

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer (arrayPtr);
            var ranks = GetRanks ();

            return new (dataPtr, ranks [0], ranks [1], 0);
        }
    }

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ImmutArray2D (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ImmutArray2D (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public T this [ES_ArrayIndex x, ES_ArrayIndex y] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
            var ranks = GetRanks ();

            if (x < 0 || x >= ranks [0])
                throw new IndexOutOfRangeException ("Index x is out of range.");
            if (y < 0 || y >= ranks [1])
                throw new IndexOutOfRangeException ("Index y is out of range.");

            return dataPtr [x + y * ranks [0]];
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static implicit operator ES_ConstArray2D<T> (ES_ImmutArray2D<T> self) => new (self.arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_ImmutArray2D<T> (ES_ImmutArray1D<T> other) {
        if (other.arrayPtr->Rank != 2)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ImmutArray1D<T> AsArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ConstArray1D<T> AsConstArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ImmutArray2D<T> left, ES_ImmutArray2D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ImmutArray2D<T> left, ES_ImmutArray2D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ImmutArray2D<T> left, ES_ConstArray2D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ImmutArray2D<T> left, ES_ConstArray2D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ImmutArray2D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ConstArray2D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_ImmutArray2D<T> other)
            return Equals (other);
        else if (obj is ES_ConstArray2D<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, ES_Constness.Immutable, 2);
    }

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_ConstArray2D<T> : IES_ReferenceType, IEquatable<ES_ConstArray2D<T>>, IEquatable<ES_Array2D<T>>, IEquatable<ES_ImmutArray2D<T>>
    where T : unmanaged {
    public static ES_ConstArray2D<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;

    public ReadOnlySpan2D<T> Span {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (arrayPtr == null)
                return Span2D<T>.Empty;

            Debug.Assert (arrayPtr->Rank == 2);

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer (arrayPtr);
            var ranks = GetRanks ();

            return new (dataPtr, ranks [0], ranks [1], 0);
        }
    }

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ConstArray2D (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ConstArray2D (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public T this [ES_ArrayIndex x, ES_ArrayIndex y] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
            var ranks = GetRanks ();

            if (x < 0 || x >= ranks [0])
                throw new IndexOutOfRangeException ("Index x is out of range.");
            if (y < 0 || y >= ranks [1])
                throw new IndexOutOfRangeException ("Index y is out of range.");

            return dataPtr [x + y * ranks [0]];
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ConstArray1D<T> AsConstArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_ConstArray2D<T> (ES_Array1D<T> other) {
        if (other.arrayPtr->Rank != 2)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ConstArray2D<T> left, ES_Array2D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ConstArray2D<T> left, ES_Array2D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_Array2D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_ConstArray2D<T> (ES_ImmutArray1D<T> other) {
        if (other.arrayPtr->Rank != 2)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ConstArray2D<T> left, ES_ImmutArray2D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ConstArray2D<T> left, ES_ImmutArray2D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ImmutArray2D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_ConstArray2D<T> (ES_ConstArray1D<T> other) {
        if (other.arrayPtr->Rank != 2)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ConstArray2D<T> left, ES_ConstArray2D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ConstArray2D<T> left, ES_ConstArray2D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ConstArray2D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_Array2D<T> otherMutable)
            return Equals (otherMutable);
        if (obj is ES_ImmutArray2D<T> otherImmutable)
            return Equals (otherImmutable);
        if (obj is ES_ConstArray2D<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, ES_Constness.Const, 2);
    }

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_Array3D<T> : IES_ReferenceType, IEquatable<ES_Array3D<T>>, IEquatable<ES_ConstArray3D<T>>
    where T : unmanaged {
    public static ES_Array3D<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_Array3D (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_Array3D (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public ref T this [ES_ArrayIndex x, ES_ArrayIndex y, ES_ArrayIndex z] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
            var ranks = GetRanks ();

            if (x < 0 || x >= ranks [0])
                throw new IndexOutOfRangeException ("Index x is out of range.");
            if (y < 0 || y >= ranks [1])
                throw new IndexOutOfRangeException ("Index y is out of range.");
            if (z < 0 || z >= ranks [2])
                throw new IndexOutOfRangeException ("Index z is out of range.");

            return ref dataPtr [x + y * ranks [0] + z * ranks [0] * ranks [1]];
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static implicit operator ES_ConstArray3D<T> (ES_Array3D<T> self) => new (self.arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_Array3D<T> (ES_Array1D<T> other) {
        if (other.arrayPtr->Rank != 3)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_Array1D<T> AsArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ConstArray1D<T> AsConstArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_Array3D<T> left, ES_Array3D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_Array3D<T> left, ES_Array3D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_Array3D<T> left, ES_ConstArray3D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_Array3D<T> left, ES_ConstArray3D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_Array3D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ConstArray3D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_Array3D<T> other)
            return Equals (other);
        else if (obj is ES_ConstArray3D<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, ES_Constness.Mutable, 3);
    }

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_ImmutArray3D<T> : IES_ReferenceType, IEquatable<ES_ImmutArray3D<T>>, IEquatable<ES_ConstArray3D<T>>
    where T : unmanaged {
    public static ES_ImmutArray3D<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ImmutArray3D (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ImmutArray3D (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public T this [ES_ArrayIndex x, ES_ArrayIndex y, ES_ArrayIndex z] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
            var ranks = GetRanks ();

            if (x < 0 || x >= ranks [0])
                throw new IndexOutOfRangeException ("Index x is out of range.");
            if (y < 0 || y >= ranks [1])
                throw new IndexOutOfRangeException ("Index y is out of range.");
            if (z < 0 || z >= ranks [2])
                throw new IndexOutOfRangeException ("Index z is out of range.");

            return dataPtr [x + y * ranks [0] + z * ranks [0] * ranks [1]];
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static implicit operator ES_ConstArray3D<T> (ES_ImmutArray3D<T> self) => new (self.arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_ImmutArray3D<T> (ES_ImmutArray1D<T> other) {
        if (other.arrayPtr->Rank != 3)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ImmutArray1D<T> AsArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ConstArray1D<T> AsConstArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ImmutArray3D<T> left, ES_ImmutArray3D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ImmutArray3D<T> left, ES_ImmutArray3D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ImmutArray3D<T> left, ES_ConstArray3D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ImmutArray3D<T> left, ES_ConstArray3D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ImmutArray3D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ConstArray3D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_ImmutArray3D<T> other)
            return Equals (other);
        else if (obj is ES_ConstArray3D<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, ES_Constness.Immutable, 3);
    }

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_ConstArray3D<T> : IES_ReferenceType, IEquatable<ES_ConstArray3D<T>>, IEquatable<ES_Array3D<T>>, IEquatable<ES_ImmutArray3D<T>>
    where T : unmanaged {
    public static ES_ConstArray3D<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ConstArray3D (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ConstArray3D (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public T this [ES_ArrayIndex x, ES_ArrayIndex y, ES_ArrayIndex z] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
            var ranks = GetRanks ();

            if (x < 0 || x >= ranks [0])
                throw new IndexOutOfRangeException ("Index x is out of range.");
            if (y < 0 || y >= ranks [1])
                throw new IndexOutOfRangeException ("Index y is out of range.");
            if (z < 0 || z >= ranks [2])
                throw new IndexOutOfRangeException ("Index z is out of range.");

            return dataPtr [x + y * ranks [0] + z * ranks [0] * ranks [1]];
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ConstArray1D<T> AsConstArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_ConstArray3D<T> (ES_Array1D<T> other) {
        if (other.arrayPtr->Rank != 3)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ConstArray3D<T> left, ES_Array3D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ConstArray3D<T> left, ES_Array3D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_Array3D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_ConstArray3D<T> (ES_ImmutArray1D<T> other) {
        if (other.arrayPtr->Rank != 3)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ConstArray3D<T> left, ES_ImmutArray3D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ConstArray3D<T> left, ES_ImmutArray3D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ImmutArray3D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_ConstArray3D<T> (ES_ConstArray1D<T> other) {
        if (other.arrayPtr->Rank != 3)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ConstArray3D<T> left, ES_ConstArray3D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ConstArray3D<T> left, ES_ConstArray3D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ConstArray3D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_Array3D<T> otherMutable)
            return Equals (otherMutable);
        if (obj is ES_ImmutArray3D<T> otherImmutable)
            return Equals (otherImmutable);
        if (obj is ES_ConstArray3D<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, ES_Constness.Const, 3);
    }

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_Array4D<T> : IES_ReferenceType, IEquatable<ES_Array4D<T>>, IEquatable<ES_ConstArray4D<T>>
    where T : unmanaged {
    public static ES_Array4D<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_Array4D (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_Array4D (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public ref T this [ES_ArrayIndex x, ES_ArrayIndex y, ES_ArrayIndex z, ES_ArrayIndex w] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
            var ranks = GetRanks ();

            if (x < 0 || x >= ranks [0])
                throw new IndexOutOfRangeException ("Index x is out of range.");
            if (y < 0 || y >= ranks [1])
                throw new IndexOutOfRangeException ("Index y is out of range.");
            if (z < 0 || z >= ranks [2])
                throw new IndexOutOfRangeException ("Index z is out of range.");
            if (w < 0 || w >= ranks [3])
                throw new IndexOutOfRangeException ("Index w is out of range.");

            return ref dataPtr [x + y * ranks [0] + z * ranks [0] * ranks [1] + w * ranks [0] * ranks [1] * ranks [2]];
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static implicit operator ES_ConstArray4D<T> (ES_Array4D<T> self) => new (self.arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_Array4D<T> (ES_Array1D<T> other) {
        if (other.arrayPtr->Rank != 4)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_Array1D<T> AsArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ConstArray1D<T> AsConstArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_Array4D<T> left, ES_Array4D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_Array4D<T> left, ES_Array4D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_Array4D<T> left, ES_ConstArray4D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_Array4D<T> left, ES_ConstArray4D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_Array4D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ConstArray4D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_Array4D<T> other)
            return Equals (other);
        else if (obj is ES_ConstArray4D<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, ES_Constness.Mutable, 4);
    }

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_ImmutArray4D<T> : IES_ReferenceType, IEquatable<ES_ImmutArray4D<T>>, IEquatable<ES_ConstArray4D<T>>
    where T : unmanaged {
    public static ES_ImmutArray4D<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ImmutArray4D (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ImmutArray4D (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public T this [ES_ArrayIndex x, ES_ArrayIndex y, ES_ArrayIndex z, ES_ArrayIndex w] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
            var ranks = GetRanks ();

            if (x < 0 || x >= ranks [0])
                throw new IndexOutOfRangeException ("Index x is out of range.");
            if (y < 0 || y >= ranks [1])
                throw new IndexOutOfRangeException ("Index y is out of range.");
            if (z < 0 || z >= ranks [2])
                throw new IndexOutOfRangeException ("Index z is out of range.");
            if (w < 0 || w >= ranks [3])
                throw new IndexOutOfRangeException ("Index w is out of range.");

            return dataPtr [x + y * ranks [0] + z * ranks [0] * ranks [1] + w * ranks [0] * ranks [1] * ranks [2]];
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static implicit operator ES_ConstArray4D<T> (ES_ImmutArray4D<T> self) => new (self.arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_ImmutArray4D<T> (ES_ImmutArray1D<T> other) {
        if (other.arrayPtr->Rank != 4)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ImmutArray1D<T> AsArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ConstArray1D<T> AsConstArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ImmutArray4D<T> left, ES_ImmutArray4D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ImmutArray4D<T> left, ES_ImmutArray4D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ImmutArray4D<T> left, ES_ConstArray4D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ImmutArray4D<T> left, ES_ConstArray4D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ImmutArray4D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ConstArray4D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_ImmutArray4D<T> other)
            return Equals (other);
        else if (obj is ES_ConstArray4D<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, ES_Constness.Immutable, 4);
    }

    #endregion
}

[StructLayout (LayoutKind.Sequential, Pack = 1)]
public unsafe readonly struct ES_ConstArray4D<T> : IES_ReferenceType, IEquatable<ES_ConstArray4D<T>>, IEquatable<ES_Array4D<T>>, IEquatable<ES_ImmutArray4D<T>>
    where T : unmanaged {
    public static ES_ConstArray4D<T> Null {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get => new (null);
    }

    #region ================== Instance fields and properties

    internal readonly ES_ArrayHeader* arrayPtr;

    #endregion

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ConstArray4D (ES_ArrayAddress ptr) => arrayPtr = ptr.Address;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    internal ES_ConstArray4D (ES_ArrayHeader* ptr) => arrayPtr = ptr;

    public T this [ES_ArrayIndex x, ES_ArrayIndex y, ES_ArrayIndex z, ES_ArrayIndex w] {
        [MethodImpl (MethodImplOptions.AggressiveInlining)]
        get {
            if (IsNull ())
                throw new NullReferenceException ();

            var dataPtr = ES_ArrayHeader.GetArrayDataPointer<T> (arrayPtr);
            var ranks = GetRanks ();

            if (x < 0 || x >= ranks [0])
                throw new IndexOutOfRangeException ("Index x is out of range.");
            if (y < 0 || y >= ranks [1])
                throw new IndexOutOfRangeException ("Index y is out of range.");
            if (z < 0 || z >= ranks [2])
                throw new IndexOutOfRangeException ("Index z is out of range.");
            if (w < 0 || w >= ranks [3])
                throw new IndexOutOfRangeException ("Index w is out of range.");

            return dataPtr [x + y * ranks [0] + z * ranks [0] * ranks [1] + w * ranks [0] * ranks [1] * ranks [2]];
        }
    }

    #region ================== Instance methods

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<ES_ArrayIndex> GetRanks ()
        => new ReadOnlySpan<ES_ArrayIndex> (ES_ArrayHeader.GetArrayRanksPointer (arrayPtr), arrayPtr->Rank);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public bool IsNull () => arrayPtr == null;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public ES_ConstArray1D<T> AsConstArray1D () => new (arrayPtr);

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_ConstArray4D<T> (ES_Array1D<T> other) {
        if (other.arrayPtr->Rank != 4)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ConstArray4D<T> left, ES_Array4D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ConstArray4D<T> left, ES_Array4D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_Array4D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_ConstArray4D<T> (ES_ImmutArray1D<T> other) {
        if (other.arrayPtr->Rank != 4)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ConstArray4D<T> left, ES_ImmutArray4D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ConstArray4D<T> left, ES_ImmutArray4D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ImmutArray4D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public static explicit operator ES_ConstArray4D<T> (ES_ConstArray1D<T> other) {
        if (other.arrayPtr->Rank != 4)
            return new (null);

        return new (other.arrayPtr);
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator == (ES_ConstArray4D<T> left, ES_ConstArray4D<T> right) => left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public static bool operator != (ES_ConstArray4D<T> left, ES_ConstArray4D<T> right) => !left.Equals (right);

    [MethodImpl (MethodImplOptions.AggressiveInlining)] public bool Equals (ES_ConstArray4D<T> other) => other.arrayPtr == arrayPtr;

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override bool Equals ([NotNullWhen (true)] object? obj) {
        if (obj is ES_Array4D<T> otherMutable)
            return Equals (otherMutable);
        if (obj is ES_ImmutArray4D<T> otherImmutable)
            return Equals (otherImmutable);
        if (obj is ES_ConstArray4D<T> otherConst)
            return Equals (otherConst);

        return false;
    }

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode () => ((nint) arrayPtr).GetHashCode ();

    [MethodImpl (MethodImplOptions.AggressiveInlining)]
    void IES_ReferenceType.InitializeType (ES_TypeTable.TypeLoader typeLoader, ref ES_TypeTable.TypeLoadToken typeToken) {
        typeLoader.CreateArray<T> (ref typeToken, ES_Constness.Const, 4);
    }

    #endregion
}

